{
    "collab_server" : "",
    "contents" : "library(shiny)\nlibrary(RMySQL)\nlibrary(ggplot2)\nlibrary(leaflet)\nlibrary(htmltools)\nlibrary(ggmap)\nlibrary(dplyr)\nlibrary(data.table)\nlibrary(gridExtra)\n\nisThereNewFile = function(){\n  #  cheap function whose values over time will be tested for equality;\n  #  inequality indicates that the underlying value has changed and needs to be \n  #  invalidated and re-read using valueFunc\n  filesnams<- list.files(path = \"master_data\",pattern = \" *.csv\",full.names = TRUE)\n  length(filesnams)\n}\n\nReadAllData=function(){ # A function that calculates the underlying value\n  filenames <- list.files(path =\"master_data\",pattern=\"*.csv\", full.names=TRUE)\n  read_csv(filenames[length(filenames)])\n}\n\nget_new_master_data<- function(){\n  files <- list.files(path = \"master_data\",\n                      pattern = \".csv\",\n                      full.names = TRUE)\n  files_factor <- as.factor(files)\n  temp <- lapply(files, fread, sep=\",\")\n  data <- rbindlist( temp )\n  a =0 \n  a = 1 \n  return(data)\n}\n\n  \nshinyServer(function(input, output,session) {\n  \n   \n  update_data_master_data <- function(){\n    \n    data.frame <<-get_new_master_data()\n  }\n  \n  \n  data.frame<- get_new_master_data()\n  datsetFrame <- get_new_master_data()\n  latLong_data <- read.csv(\"lat-long-data/latLong.csv\",header = T)\n  #data frame for map data\n  \n  observe({\n  \n    invalidateLater(60000,session)\n    \n  b<-table(data.frame$terminatingCircle,data.frame$terminatingOperator)\n  bn <- as.data.frame(b)\n  bn<-aggregate(bn$Freq, by=list(Category=bn$Var1), FUN=sum)\n  colnames(bn)<- c(\"terminatingCircle\",\"DeliveryCount\")\n # origAddress<-bn\n  origAddress<-bn\n      })\n\n  \n  #### getting the data for missed call \n  \n  get_new_missed_Call_data <- function(){\n    files <- list.files(path = \"missCallData\",\n                        pattern = \".csv\",\n                        full.names = TRUE)\n    files_factor <- as.factor(files)\n    temp <- lapply(files, fread, sep=\",\")\n    data <- rbindlist( temp )\n    a =0 \n    a = 1\n    \n    data <- subset(data, select = c(iUserId,day,time,Hour,iAllotedVMN,date))\n    return(data)\n  \n  }\n  update_missed_call_data <- function(){\n      dataFormatFinal <- get_new_missed_Call_data()\n  }\n \n  dataFormatFinal <-get_new_missed_Call_data()\n   \n  \n  observe({\n    y<-unique(data.frame$senderId)\n    updateSelectInput(session ,\"senderId\",label = \"select the SenderId\",\n                      choices = append(y,\"All\"),selected = \"DM-BOISTR\")\n  })\n  observe({\n    \n    x<- unique(datsetFrame$terminatingCircle)\n    \n    updateSelectInput(session,\"terminatingCircle\",label = \"Select the Terminating Circle\",choices = append(x,\"All\"),\n                      selected = \"Mumbai\")\n  })\n  \n  \n  plotInput4 <- reactive({\n    \n    \n    if(input$senderId == 'All'){\n      input$refresh # refresh if button is clicked\n      #get interval (minimum 30)\n      interval <- max(as.numeric(input$interval),30)\n      invalidateLater(interval * 1000,session)\n      # datsetFrame<-data.frame\n      #update_data_master_data()\n      datsetFrame<-data.frame\n      datsetFrame <- datsetFrame[,c(\"terminatingOperator\",\"terminatingCircle\",\"procDate\",\"msgType\",\"senderId\")]\n      datsetFrame$procDate = as.Date(datsetFrame$procDate)\n      withProgress(message = 'Calculation in progress',\n                   detail = 'This may take a while...', value = 0, {\n                     for (i in 1:15) {\n                       incProgress(1/15)\n                       Sys.sleep(0.25)\n                     }\n                   })\n      g<- ggplot(datsetFrame %>% count(senderId, msgType) %>%    # Group by region and species, then count number in each group\n                   mutate(pct=n/sum(n),               # Calculate percent within each region\n                          ypos = cumsum(n) - 0.5*n),  # Calculate label positions\n                 aes(senderId, n, fill=msgType)) +\n        geom_bar(stat=\"identity\", width = 0.2) + ggtitle(\"Types Of Message send by sender (Filter -> senderId and date)\")+\n        geom_text(aes(label=n),  vjust=-1.1) + labs(y = \"Type of message\")\n      \n      g\n      \n    }else{\n      input$refresh # refresh if button is clicked\n      #get interval (minimum 30)\n      interval <- max(as.numeric(input$interval),30)\n      invalidateLater(interval * 1000,session)\n      # datsetFrame<-data.frame\n      #update_data_master_data()\n      datsetFrame<-data.frame\n      datsetFrame <- datsetFrame[,c(\"terminatingOperator\",\"terminatingCircle\",\"procDate\",\"msgType\",\"senderId\")]\n      datsetFrame$procDate = as.Date(datsetFrame$procDate)\n      datsetFrame <- datsetFrame[which(\n        datsetFrame$senderId == input$senderId\n        #& datsetFrame$procDate <= as.Date(input$dateRangeID[2])\n        #& datsetFrame$procDate >= as.Date(input$dateRangeID[1])\n      ),]\n      \n      \n      withProgress(message = 'Calculation in progress',\n                   detail = 'This may take a while...', value = 0, {\n                     for (i in 1:15) {\n                       incProgress(1/15)\n                       Sys.sleep(0.25)\n                     }\n                   })\n      \n      \n      g<- ggplot(datsetFrame %>% count(senderId, msgType) %>%    # Group by region and species, then count number in each group\n                   mutate(pct=n/sum(n),               # Calculate percent within each region\n                          ypos = cumsum(n) - 0.5*n),  # Calculate label positions\n                 aes(senderId, n, fill=msgType)) +\n        geom_bar(stat=\"identity\", width = 0.2) + ggtitle(\"Types Of Message send by sender (Filter -> senderId and date)\")+\n        geom_text(aes(label=n),  vjust=-1.1) + labs(y = \"Type of message\")\n      \n      g\n    }\n    \n    \n    \n  })\n  \n  plotInput2 <- reactive({\n    \n    if(input$terminatingCircle == \"All\"){\n      \n      input$refresh # refresh if button is clicked\n      \n      #get interval (minimum 30)\n      interval <- max(as.numeric(input$interval),30)\n      invalidateLater(interval * 1000,session)\n      # datsetFrame<-data.frame\n      #update_data_master_data()\n      datsetFrame<-data.frame\n      datsetFrame <- datsetFrame[,c(\"terminatingOperator\",\"terminatingCircle\",\"procDate\")]\n      datsetFrame$procDate = as.Date(datsetFrame$procDate)\n      withProgress(message = 'Calculation in progress',\n                   detail = 'This may take a while...', value = 0, {\n                     for (i in 1:15) {\n                       incProgress(1/15)\n                       Sys.sleep(0.25)\n                     } \n                   })\n      \n      g<- ggplot(datsetFrame %>% count(terminatingOperator, terminatingCircle) %>%    # Group by region and species, then count number in each group\n                   mutate(pct=n/sum(n),               # Calculate percent within each region\n                          ypos = cumsum(n) - 0.5*n),  # Calculate label positions\n                 aes(terminatingOperator, n, fill=terminatingCircle)) +\n        geom_bar(stat=\"identity\", width = 0.2) + coord_flip() +\n        geom_text(aes(label=n),  vjust=-1.1) + ggtitle(\"Message Deivered in particular states(Filter ->Terminating circle and date)\")\n      g\n      \n    }else{\n      \n      input$refresh # refresh if button is clicked\n      \n      #get interval (minimum 30)\n      interval <- max(as.numeric(input$interval),30)\n      invalidateLater(interval * 1000,session)\n      # datsetFrame<-data.frame\n      #update_data_master_data()\n      datsetFrame<-data.frame\n      datsetFrame <- datsetFrame[,c(\"terminatingOperator\",\"terminatingCircle\",\"procDate\")]\n      datsetFrame$procDate = as.Date(datsetFrame$procDate)\n      datsetFrame <- datsetFrame[which(#datsetFrame$terminatingOperator == input$terminatingOperator \n        datsetFrame$terminatingCircle == input$terminatingCircle\n        #& datsetFrame$procDate <= as.Date(input$dateRangeID[2])\n        #& datsetFrame$procDate >= as.Date(input$dateRangeID[1])\n      ),]\n      ###\n      \n      \n      withProgress(message = 'Calculation in progress',\n                   detail = 'This may take a while...', value = 0, {\n                     for (i in 1:15) {\n                       incProgress(1/15)\n                       Sys.sleep(0.25)\n                     } \n                   })\n      \n      g<- ggplot(datsetFrame %>% count(terminatingOperator, terminatingCircle) %>%    # Group by region and species, then count number in each group\n                   mutate(pct=n/sum(n),               # Calculate percent within each region\n                          ypos = cumsum(n) - 0.5*n),  # Calculate label positions\n                 aes(terminatingOperator, n, fill=terminatingCircle)) +\n        geom_bar(stat=\"identity\", width = 0.2) + coord_flip() +\n        geom_text(aes(label=n),  vjust=-1.1) + ggtitle(\"Message Deivered in particular states(Filter ->Terminating circle and date)\")\n      g\n    }\n  })\n  \n  plotInput3 <- reactive({\n    \n    if (input$senderId == \"All\"){\n      \n      input$refresh # refresh if button is clicked\n      \n      #get interval (minimum 30)\n      interval <- max(as.numeric(input$interval),30)\n      invalidateLater(interval * 1000,session)\n      #datsetFrame<-data.frame\n      #update_data_master_data()\n      datsetFrame<-data.frame\n      datsetFrame <- datsetFrame[,c(\"terminatingCircle\",\"procDate\",\"senderId\")]\n      datsetFrame$procDate = as.Date(datsetFrame$procDate)\n      \n      withProgress(message = 'Calculation in progress',\n                   detail = 'This may take a while...', value = 0, {\n                     for (i in 1:15) {\n                       incProgress(1/15)\n                       Sys.sleep(0.25)\n                     }\n                   })\n      \n      june1<-ggplot(datsetFrame, aes(senderId) ) +\n        geom_bar(stat = \"count\",width = 0.1) + geom_text(stat='count',aes(label=..count..),vjust=-1) +\n        ggtitle(\"Total Message Delivered (filter->SenderId and date)\")\n      june1\n      \n    }else{\n      \n      \n      input$refresh # refresh if button is clicked\n      \n      #get interval (minimum 30)\n      interval <- max(as.numeric(input$interval),30)\n      invalidateLater(interval * 1000,session)\n      #datsetFrame<-data.frame\n      #update_data_master_data()\n      datsetFrame<-data.frame\n      datsetFrame <- datsetFrame[,c(\"terminatingCircle\",\"procDate\",\"senderId\")]\n      datsetFrame$procDate = as.Date(datsetFrame$procDate)\n      datsetFrame <- datsetFrame[which(\n        datsetFrame$senderId == input$senderId\n        #& datsetFrame$procDate <= as.Date(input$dateRangeID[2])\n        #& datsetFrame$procDate >= as.Date(input$dateRangeID[1])\n      ),]\n      \n      \n      \n      withProgress(message = 'Calculation in progress',\n                   detail = 'This may take a while...', value = 0, {\n                     for (i in 1:15) {\n                       incProgress(1/15)\n                       Sys.sleep(0.25)\n                     }\n                   })\n      \n      june1<-ggplot(datsetFrame, aes(senderId) ) +\n        geom_bar(stat = \"count\",width = 0.1) + geom_text(stat='count',aes(label=..count..),vjust=-1) +\n        ggtitle(\"Total Message Delivered (filter->SenderId and date)\")\n      june1\n      \n      \n    }\n  })\n  \n  plotInput1 <-reactive({\n    \n    input$refresh # refresh if button is clicked\n    \n    if(input$terminatingCircle == \"All\"){\n      \n      interval <- max(as.numeric(input$interval),30)\n      invalidateLater(interval * 1000,session)\n      # datsetFrame<-data.frame\n      #update_data_master_data()\n      datsetFrame<-data.frame\n      datsetFrame <- datsetFrame[,c(\"terminatingOperator\",\"terminatingCircle\",\"procDate\",\"msgType\")]\n      datsetFrame$procDate = as.Date(datsetFrame$procDate)\n      withProgress(message = 'Calculation in progress',\n                   detail = 'This may take a while...', value = 0, {\n                     for (i in 1:15) {\n                       incProgress(1/15)\n                       Sys.sleep(0.25)\n                     }\n                   })\n      g<- ggplot(datsetFrame %>% count(terminatingCircle, msgType) %>%    # Group by region and species, then count number in each group\n                   mutate(pct=n/sum(n),               # Calculate percent within each region\n                          ypos = cumsum(n) - 0.5*n),  # Calculate label positions\n                 aes(msgType, n, fill=terminatingCircle)) +\n        geom_bar(stat=\"identity\", width = 0.2) + coord_flip() +\n        geom_text(aes(label=n),  vjust=-1.1) + labs(y = \"Type of message\") + \n        ggtitle(\"Message Type in Terminating Circle (filter <- terminating circle and  Date)\")\n      \n      g\n      \n      \n      \n    }else{\n      \n      #get interval (minimum 30)\n      interval <- max(as.numeric(input$interval),30)\n      invalidateLater(interval * 1000,session)\n      # datsetFrame<-data.frame\n      #update_data_master_data()\n      datsetFrame<-data.frame\n      datsetFrame <- datsetFrame[,c(\"terminatingOperator\",\"terminatingCircle\",\"procDate\",\"msgType\")]\n      datsetFrame$procDate = as.Date(datsetFrame$procDate)\n      datsetFrame <- datsetFrame[which(#datsetFrame$terminatingOperator == input$terminatingOperator \n        datsetFrame$terminatingCircle == input$terminatingCircle\n        #& datsetFrame$procDate <= as.Date(input$dateRangeID[2])\n        #& datsetFrame$procDate >= as.Date(input$dateRangeID[1])\n      ),]\n      ###\n      \n      \n      withProgress(message = 'Calculation in progress',\n                   detail = 'This may take a while...', value = 0, {\n                     for (i in 1:15) {\n                       incProgress(1/15)\n                       Sys.sleep(0.25)\n                     }\n                   })\n      \n      \n      g<- ggplot(datsetFrame %>% count(terminatingCircle, msgType) %>%    # Group by region and species, then count number in each group\n                   mutate(pct=n/sum(n),               # Calculate percent within each region\n                          ypos = cumsum(n) - 0.5*n),  # Calculate label positions\n                 aes(msgType, n, fill=terminatingCircle)) +\n        geom_bar(stat=\"identity\", width = 0.2) + coord_flip() +\n        geom_text(aes(label=n),  vjust=-1.1) + labs(y = \"Type of message\") + ggtitle(\"Message Type in Terminating Circle (filter <- terminating circle and  Date)\")\n      \n      g\n    }\n  })\n  \n  output$plot1 <- renderPlot({\n    print(plotInput1())\n\n  })\n  \n  \n  output$plot4 <- renderPlot({\n    print(plotInput4())\n    \n  })\n  \n  \n  \n  \n  \n  output$plot3 <- renderPlot({\n   print(plotInput3())\n  })\n  \n  \n  \n  \n  output$mymap<- renderLeaflet({\n    input$refresh # refresh if button is clicked\n                  #get interval (minimum 30)\n    interval <- max(as.numeric(input$interval),30)\n    invalidateLater(interval * 1000,session)\n    update_data_master_data()\n    b<-table(data.frame$terminatingCircle,data.frame$terminatingOperator)\n    bn <- as.data.frame(b)\n    bn<-aggregate(bn$Freq, by=list(Category=bn$Var1), FUN=sum)\n    colnames(bn)<- c(\"terminatingCircle\",\"DeliveryCount\")\n    # origAddress<-bn\n    origAddress<-bn\n    withProgress(message = 'Calculation in progress',\n                 detail = 'This may take a while...', value = 0, {\n                   for (i in 1:15) {\n                     incProgress(1/15)\n                     Sys.sleep(0.25)\n                   }\n                 })\n    origAddress <- left_join(x = origAddress,y = latLong_data,by = c(\"terminatingCircle\" = \"State\") )\n  \n    withProgress(message = 'Calculation in progress',\n                 detail = 'This may take a while...', value = 0, {\n                   for (i in 1:15) {\n                     incProgress(1/15)\n                     Sys.sleep(0.25)\n                   }\n                 })\n    \n    origAddress$lat<-as.numeric(as.character(origAddress$lat))\n    origAddress$long<- as.numeric(as.character(origAddress$long))\n    colnames(origAddress)<- c(\"terminatingCircle\",\"DeliveryCount\",\"long\",\"lat\")\n    leeafletData<-origAddress[complete.cases(origAddress),]\n    \n    m<-leaflet(leeafletData) %>% addTiles() %>%\n      addMarkers(~long,~lat,label = \"No of message delivered\",popup = ~htmlEscape(\n        as.character(DeliveryCount)\n      ))\n    withProgress(message = 'Calculation in progress',\n                 detail = 'This may take a while...', value = 0, {\n                   for (i in 1:15) {\n                     incProgress(1/15)\n                     Sys.sleep(0.25)\n                   }\n                 })\n    m\n  })\n  \n  \n  \n  \n  output$table <- renderDataTable({\n    input$refresh # refresh if button is clicked\n    \n    #get interval (minimum 30)\n    interval <- max(as.numeric(input$interval),30)\n    invalidateLater(interval * 1000,session)\n    \n    update_missed_call_data()\n    dataFormatFinalHour<- dataFormatFinal[which(\n      dataFormatFinal$iAllotedVMN == input$vmn & dataFormatFinal$iUserId == input$userId\n    ),]\n    dataFormatFinalHour\n  })\n  \n  output$plot2<- renderPlot({\n   print(plotInput2())\n  })\n  output$down1 <- downloadHandler(\n     \n    \n    filename = function(){\n       paste(input$terminatingCircle,'.pdf',sep = '.')\n     },\n    content = function(file){\n      ggsave(file,plotInput1())\n      \n    }\n    \n  )\n  output$down2<- downloadHandler(\n    filename = function(){\n      paste(input$senderId,'.pdf',sep = '.')\n    },\n    content = function(file){\n      ggsave(file,plotInput2())\n    }\n  )\n  output$down3 <- downloadHandler(\n    filename = function(){\n      paste(input$senderId,'.pdf',sep = '.')\n      ggsave(file,plotInput3())\n    },\n    content = function(file){}  \n  )\n  output$down4 <- downloadHandler(\n    filename = function(){\n      paste(input$terminatingCircle,'.pdf',sep = '.')\n    },\n    content = function(file){\n      ggsave  (file,plotInput4())\n    }\n  )\n  \n})\n",
    "created" : 1499417918709.000,
    "dirty" : true,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "3224139033",
    "id" : "8D9EA44A",
    "lastKnownWriteTime" : 1499835931,
    "last_content_update" : 1499836377483,
    "path" : "~/dashboard/RouteMobileDashboard/server.R",
    "project_path" : "server.R",
    "properties" : {
    },
    "relative_order" : 3,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}